{
  "version": 3,
  "sources": ["../src/index.js"],
  "sourcesContent": ["/*!\r\n * Copyright (c) 2026 Stefan Keim\r\n * MIT License \u2014 see LICENSE file for details\r\n */\r\n\r\naddProtocol('merge', async (params, abortController) => {\r\n\r\n    const urls = params.url.replace('merge://', '').split('|');\r\n\r\n    const tiles = await Promise.all(\r\n        urls.map(async (url) => {\r\n            const resp = await makeRequest({ ...params, url }, abortController);\r\n            return tile.read(new Pbf(resp.data));\r\n        })\r\n    );\r\n\r\n    console.time(params.url.replaceAll(location.origin,'.'));\r\n\r\n    const [base, ...attrTiles] = tiles; // base at index 0, all others are attr\r\n\r\n    for (const attr of attrTiles) {\r\n        if (base.layers.length !== attr.layers.length) {\r\n            throw new Error('Layer count mismatch');\r\n        }\r\n\r\n        for (let i = 0; i < base.layers.length; i++) {\r\n            const bl = base.layers[i];\r\n            const al = attr.layers[i];\r\n\r\n            if (bl.features.length !== al.features.length) {\r\n                throw new Error(`Feature count mismatch in layer ${i}`);\r\n            }\r\n\r\n            // Keep track of key/value offset\r\n            const keyOffset = bl.keys.length;\r\n            if (keyOffset == 0) {\r\n                bl.keys = al.keys;\r\n                bl.values = al.values;\r\n                for (let j = 0; j < bl.features.length; j++) {\r\n                    bl.features[j].tags = al.features[j].tags;\r\n                }\r\n            } else {\r\n                const valueOffset = bl.values.length;\r\n\r\n                for (let j = 0; j < al.keys.length; j++) bl.keys.push(al.keys[j]);\r\n                for (let j = 0; j < al.values.length; j++) bl.values.push(al.values[j]);\r\n\r\n                for (let j = 0; j < bl.features.length; j++) {\r\n                    const tags = bl.features[j].tags;\r\n                    const alTags = al.features[j].tags;\r\n\r\n                    for (let k = 0; k < alTags.length; k += 2) {\r\n                        tags.push(alTags[k] + keyOffset, alTags[k + 1] + valueOffset);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const pbf = new Pbf();\r\n    tile.write(base, pbf);\r\n    const data = pbf.finish()\r\n\r\n    console.timeEnd(params.url.replaceAll(location.origin,'.'));\r\n\r\n    return { data };\r\n});\r\n\r\n\r\nconst shMod = self.sharedModule;\r\nlet Pbf = shMod.Pbf;\r\nlet makeRequest = shMod.makeRequest;\r\n\r\n// Locate utility functions in `sharedModules` in the minified build,\r\n// since MapLibre is built with Rollup\u2019s `minifyInternalExports` enabled.\r\n// The markers have been tested for MapLibre minor versions v4.0\u2013v5.17.\r\n\r\nconsole.time(\"sharedModules\")\r\nif (!Pbf || !makeRequest) {\r\n\r\n    const Pbf_marker = 'ArrayBuffer.isView'\r\n    const makeRequest_marker = 'getResponseHeader(\"Content-Type\")'\r\n\r\n    for (const key in shMod) {\r\n        const item = shMod[key];\r\n\r\n        if (typeof item === 'function') {\r\n            const str = item.toString();\r\n\r\n            if (!Pbf && str.includes(Pbf_marker)) {\r\n                // fix for MapLibre minor versions v5.0\u2013v5.3\r\n                Pbf = typeof new item === \"function\" ? new item : item\r\n                if (makeRequest) break;\r\n            }\r\n\r\n            if (!makeRequest && str.includes(makeRequest_marker)) {\r\n                makeRequest = item;\r\n                if (Pbf) break;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!Pbf || !makeRequest) {\r\n        throw new Error('Unable to find sharedModules');\r\n    }\r\n}\r\nconsole.timeEnd(\"sharedModules\")\r\n\r\nconst tile = {\r\n    read(pbf, end) {\r\n        return pbf.readFields((tag, obj, pbf) => {\r\n            if (tag === 3) obj.layers.push(tile.readL(pbf, pbf.readVarint() + pbf.pos));\r\n        }, { layers: [] }, end);\r\n    },\r\n    write(obj, pbf) {\r\n        if (obj.layers) for (let i = 0; i < obj.layers.length; i++) pbf.writeMessage(3, tile.writeL, obj.layers[i]);\r\n    },\r\n\r\n    // value\r\n    readV(pbf, end) {\r\n        return pbf.readFields((tag, obj, pbf) => {\r\n            if (tag === 1) obj.string = pbf.readString();\r\n            else if (tag === 2) obj.float = pbf.readFloat();\r\n            else if (tag === 3) obj.double = pbf.readDouble();\r\n            else if (tag === 4) obj.int = pbf.readVarint(true);\r\n            else if (tag === 5) obj.uint = pbf.readVarint();\r\n            else if (tag === 6) obj.sint = pbf.readSVarint();\r\n            else if (tag === 7) obj.bool = pbf.readBoolean();\r\n        }, {}, end);\r\n    },\r\n    writeV(obj, pbf) {\r\n        if (obj.string !== undefined) pbf.writeStringField(1, obj.string);\r\n        else if (obj.float !== undefined) pbf.writeFloatField(2, obj.float);\r\n        else if (obj.double !== undefined) pbf.writeDoubleField(3, obj.double);\r\n        else if (obj.int !== undefined) pbf.writeVarintField(4, obj.int);\r\n        else if (obj.uint !== undefined) pbf.writeVarintField(5, obj.uint);\r\n        else if (obj.sint !== undefined) pbf.writeSVarintField(6, obj.sint);\r\n        else if (obj.bool !== undefined) pbf.writeBooleanField(7, obj.bool);\r\n    },\r\n\r\n    // feature\r\n    readF(pbf, end) {\r\n        return pbf.readFields((tag, obj, pbf) => {\r\n            if (tag === 1) obj.id = pbf.readVarint();\r\n            else if (tag === 2) {\r\n                pbf.readPackedVarint(obj.tags);\r\n                obj.tags.length % 2 && obj.tags.unshift(0);\r\n            }\r\n            else if (tag === 3) obj.type = pbf.readVarint();\r\n            else if (tag === 4) pbf.readPackedVarint(obj.geometry);\r\n        }, { id: 0, tags: [], type: 0, geometry: [] }, end);\r\n    },\r\n    writeF(obj, pbf) {\r\n        if (obj.id) pbf.writeVarintField(1, obj.id);\r\n        if (obj.tags) pbf.writePackedVarint(2, obj.tags);\r\n        if (obj.type) pbf.writeVarintField(3, obj.type);\r\n        if (obj.geometry) pbf.writePackedVarint(4, obj.geometry);\r\n    },\r\n\r\n    // layer\r\n    readL(pbf, end) {\r\n        return pbf.readFields((tag, obj, pbf) => {\r\n            if (tag === 2) obj.features.push(tile.readF(pbf, pbf.readVarint() + pbf.pos));\r\n            else if (tag === 3) obj.keys.push(pbf.readString());\r\n            else if (tag === 4) obj.values.push(tile.readV(pbf, pbf.readVarint() + pbf.pos));\r\n            else if (tag === 1) obj.name = pbf.readString();\r\n            else if (tag === 5) obj.extent = pbf.readVarint();\r\n            else if (tag === 15) obj.version = pbf.readVarint();\r\n        }, { version: 0, name: \"\", features: [], keys: [], values: [], extent: 0 }, end);\r\n    },\r\n    writeL(obj, pbf) {\r\n        if (obj.version) pbf.writeVarintField(15, obj.version);\r\n        if (obj.name) pbf.writeStringField(1, obj.name);\r\n        if (obj.features) for (let i = 0; i < obj.features.length; i++) pbf.writeMessage(2, tile.writeF, obj.features[i]);\r\n        if (obj.keys) for (let i = 0; i < obj.keys.length; i++) pbf.writeStringField(3, obj.keys[i]);\r\n        if (obj.values) for (let i = 0; i < obj.values.length; i++) pbf.writeMessage(4, tile.writeV, obj.values[i]);\r\n        if (obj.extent) pbf.writeVarintField(5, obj.extent);\r\n    }\r\n};"],
  "mappings": "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",
  "names": ["params", "abortController", "urls", "tiles", "url", "resp", "base", "attrTiles", "attr", "i", "bl", "al", "keyOffset", "j", "valueOffset", "tags", "alTags", "k", "pbf", "Pbf_marker", "makeRequest_marker", "key", "item", "str", "end", "tag", "obj"]
}
